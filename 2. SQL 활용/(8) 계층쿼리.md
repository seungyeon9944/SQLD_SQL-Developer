### ⭐계층 쿼리

```sql
SELECT LEVEL, # 현재의 Depth (루트 노드는 1)
       SYS_CONNECT_BY_PATH('['||CATEGORY_TYPE||']'|| CATEGORY_NAME, '-') AS PATH
       # 루트 노드부터 현재 노드까지의 경로
  FROM CATEGORY
 START WITH PARENT_CATEGORY IS NULL # 경로가 시작되는 루트 노드 생성
 CONNECT BY PRIOR CATEGORY_NAME = PARENT_CATEGORY # 루트로부터 자식 노드 생성 -> 하향식
 # (부모 행의 ID = 자식 행의 ID)
 ORDER SIBLINGS BY NAME;
```

- **`CONNECT BY PRIOR`**  : 계층 구조 내에서 행과 행 연결
    - `CONNECT BY **PRIOR** C1 = C2` : **하향식** (Top-Down)*인데 C1과 C2의 관계에 따라 달라질때도 ! CONNECT BY PRIOR 상위관리자코드 = 사원번호; 에서는 상향식*
    - `CONNECT BY C1 = **PRIOR** C2`  : **상향식** (Bottom-Up)
    - *✏️ **PRIOR** : 계층질의에서 CONNECT BY 절에 사용되며, 현재 읽은 칼럼 지정*
- **`CONNECT_BY_ROOT`** : 루트 노드의 주어진 컬럼 값 반환
- **`CONNECT_BY_ISLEAF`** : 가장 하위 노드인 경우 1 반환, 그 외에는 0 반환

*✏️ 계층 쿼리는 ORDER하면 전체 정렬이 되어버리기때문에 x !!*  `ORDER SIBLINGS` *를 써야 함*

*✏️ **LEVEL**은 1부터 시작해서 CONNECT BY 조건이 참일동안 **1씩 증가***

✏️ 오답 노트

```sql
SELECT EMPLOYEE_ID,
       NAME,
       MANAGER_ID
  FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID # 하향식
ORDER SIBLINGS BY EMPLOYEE_ID DESC;
```

[EMPLOYEES 테이블]

| **EMPLOYEE_ID** | **NAME** | **MANAGER_ID** |
| --- | --- | --- |
| 100 | Steven | NULL |
| 101 | Neena | 100 |
| 102 | Lex | 100 |
| 108 | Nancy | 101 |
| 109 | Daniel | 108 |
| 110 | John | 108 |
| 111 | Ismael | 108 |
| 112 | Jose Manuel | 108 |
| 113 | Luis | 108 |

[정답]

| **LEVEL** | **EMPLOYEE_ID** | **NAME** | **MANAGER_ID** | **설명** |
| --- | --- | --- | --- | --- |
| **1** | 100 | Steven | NULL | Root |
| **2** | 102 | Lex | 100 | Steven의 자식 중 ID가 더 큼 (102 > 101) |
| **2** | 101 | Neena | 100 | Steven의 다음 자식 |
| **3** | 108 | Nancy | 101 | Neena의 자식 |
| **4** | 113 | Luis | 108 | Nancy의 자식 중 ID가 가장 큼 |
| **4** | 112 | Jose Manuel | 108 | Nancy의 자식 |
| **4** | 111 | Ismael | 108 | Nancy의 자식 |
| **4** | 110 | John | 108 | Nancy의 자식 |
| **4** | 109 | Daniel | 108 | Nancy의 자식 중 ID가 가장 작음 |

*✏️ **START WITH를 생략**하면 루트가 없기 때문에 전 테이블의 **모든 행이 루트노드가 됨***

3개

2개

1개

| **DEPTNO** | **DNAME** | **PARENT_DEPT** |
| --- | --- | --- |
| 10 | 총무부 | NULL |
| 20 | 인사부 | 10 |
| 30 | 재무부 | 20 |

1

2 1

3 2 1

### ⭐`PIVOT`

행을 **열로 바꿈**

칼럼의 행 속성값들이 새 칼럼 헤더가 되고 전체 속성값들이 재배치됨

```sql
SELECT *
FROM (SELECT E.JOB, D.DNAME
      FROM EMP E, DEPT D
      WHERE E.DEPTNO = D.DEPTNO)
PIVOT (COUNT(*) FOR DNAME IN ('ACCOUNTING' AS ACCOUNTING,
                              'RESEARCH' AS RESEARCH,
                              'SALES' AS SALES));
# JOB, DNAME이 JOB, ACCOUNTING, RESEARCH, SALES 컬럼으로 바뀜
```

| **지점** | **Q1** | **Q2** | **Q3** |
| --- | --- | --- | --- |
| **서울** | 10 | 20 | 50 |
| **경기** | 30 | 40 | 60 |

# **→**

| **분기** | **서울** | **경기** |
| --- | --- | --- |
| **Q1** | 10 | 30 |
| **Q2** | 20 | 40 |
| **Q3** | 50 | 60 |

✏️ *PIVOT절과 같은 결과 갖게 하는법*

```sql
SELECT COUNT(DECODE(DEPTNO, 10, 1)) AS "10",
       COUNT(DECODE(DEPTNO, 20, 1)) AS "20",
       COUNT(DECODE(DEPTNO, 30, 1)) AS "30"
       # 30이 아니면 NULL 반환하므로 30의 개수를 세는 것과 동일
FROM EMP;
# 이거는

SELECT *
FROM (SELECT EMPNO, DEPTNO FROM EMP)
PIVOT (COUNT(EMPNO) FOR DEPTNO IN (10,20,30));
# 얘랑 같은 의미임
```

### ⭐`UNPIVOT`

열을 **행으로** 바꿈

```sql
SELECT 계절, 연도, 기온
FROM (SELECT * FROM 평균기온)
UNPIVOT (기온 FOR 연도 IN (Y2018 AS '2018년',
                          Y2020 AS '2020년'));
```

| **지역** | Q1 | Q2 |
| --- | --- | --- |
| **서울** | 10 | 20 |
| **경기** | 30 | 40 |

# **→**

| **지역** | **구분** | **판매량** |
| --- | --- | --- |
| 서울 | Q1 | 10 |
| 서울 | Q2 | 20 |
| 경기 | Q1 | 30 |
| 경기 | Q2 | 40 |